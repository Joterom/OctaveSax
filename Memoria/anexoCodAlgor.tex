\noindent \textbf{Fichero: algoritmo\_final.m}

\noindent function out = algoritmo\_final( input )\\

\noindent \%ALGORITMO\_FINAL Algoritmo de Ellis ajustado y tal como se va a introducir\\
\%     en la FPGA\\
\%   Utiliza el algoritmo de Ellis para implementar un octavador. Requiere\\
\%   de varias operaciones complejas que hay que buscar para implementarlas en\\
\%   FPGA:\\
\%     - Coseno\\
\%     - Exponencial\\
\%     - Arctan\\
\%     - FFT/iFFT

\noindent r = 2;\\
transform\_length = 512;\\
hop = transform\_length/4;

\noindent \% Espera la entrada como una fila, si no, la transpone\\
if size(input,1) > 1\\
  input = input';\\
end

\noindent s = length(input);\\
\% Enventanado para la STFT \\
halff = transform\_length/2;   % punto medio de la ventana\\
halfwin = 0.5 * ( 1 + cos( pi * (0:halff)/halff));\\
win\_stft = zeros(1, transform\_length);\\
win\_stft((halff+1):(halff+halff)) = halfwin(1:halff);\\
win\_stft((halff+1):-1:(halff-halff+2)) = halfwin(1:halff);\\

\noindent \% Inicializa el array de salida y las variables necesarias\\
stft\_signal = zeros((1+transform\_length/2),1+fix((s-transform\_length)/hop));\\
c\_stft = 1;\\
\% Realiza la FFT utilizando una columna por cada ventana\\
for i = 0:hop:(s-transform\_length)\\
  frame = win\_stft.*input((i+1):(i+transform\_length));\\
  tot = fft(frame);\\
  stft\_signal(:,c\_stft) = tot(1:(1+transform\_length/2))';\\
  c\_stft = c\_stft+1;\\
end;\\

\noindent [rows, cols] = size(stft\_signal);\\
t = 0:r:(cols-2);\\
\% Tiene cuidado con las columnas porque se inicializa en 0 y hace falta la\\
\% ventana siguiente para el solapamiento\\

\noindent num = 2*(rows-1);

\noindent \% Inicializa el array de salida\\
pv\_signal = zeros(rows, length(t));\\

\noindent \% Calcula la fase a esperar\\
dphi = zeros(1,num/2+1);\\
dphi(2:(1 + num/2)) = (2*pi*hop)./(num./(1:(num/2)));

\noindent \% Acumulador de fase\\
\% Se inicializa la fase de todas las muestras de la primera trama\\
ph = angle(stft\_signal(:,1));

\noindent \% Incluye una columna de seguridad para evitar problemas\\
stft\_signal = [stft\_signal,zeros(rows,1)];\\
ocol = 1;\\
for i = t\\
  \% Coge dos coulmnas\\
  bcols = stft\_signal(:,floor(i)+[1 2]);\\
  bmag = abs(bcols(:,1));\\
  \% Calcula la fase siguiente\\
  dp = angle(bcols(:,2)) - angle(bcols(:,1)) - dphi';\\
  \% La reduce a rango de -pi, pi\\
  dp = dp - 2 * pi * round(dp/(2*pi));\\
  \% Reconstruye la muestra\\ 
  pv\_signal(:,ocol) = bmag.*cos(ph) + j.*bmag.*sin(ph);\\
  \% La fase calculada corresponde a la siguiente trama\\
  ph = ph + dphi' + dp;\\
  ocol = ocol+1;\\
end\\

\noindent \% inicializa las variables necesarias\\
s = size(pv\_signal);\\
cols = s(2);\\
win\_istft = 2/3*win\_stft;\\

\noindent \% Inicializa las variables de salida y procede a hacer transformada
\% inversa
xlen = transform\_length + (cols-1)*hop;\\
istft\_signal = zeros(1,xlen);\\
for i = 0:hop:(hop*(cols-1))\\
  ft = pv\_signal(:,1+i/hop)';\\
  ft = [ft, conj(ft([((transform\_length/2)):-1:2]))];\\
  px = real(ifft(ft));\\
  istft\_signal((i+1):(i+transform\_length)) = istft\_signal((i+1):(i+transform\_length))+px.*win\_istft;\\
end\\

\noindent \% PREPARACION FINAL +++++++++++++++++++

\noindent \% Remuestreo (interpolacion) tras filtrado antialiasing\\
pre\_out = resample(istft\_signal,2,1);\\
\% Fuerza a la salida a tener la misma longitud que a la entrada\\
if length(pre\_out) == length(input)\\
    out = pre\_out';\\
else\\
    out = zeros(size(input));\\
    out(1,1:end) = pre\_out(1,1:length(input))';\\
end\\
end\\