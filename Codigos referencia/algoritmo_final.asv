function out = algoritmo_final( input )
%ALGORITMO_FINAL Algoritmo de Ellis ajustado y tal como se va a introducir
%     en la FPGA
%   Utiliza el algoritmo de Ellis para implementar un octavador. Requiere
%   de varias operacioes "complejas" que hay que buscar para implemntar en
%   FPGA:
%     - Coseno
%     - Exponencial
%     - Arcotangente
%     - FFT/iFFT

r = 2;
transform_length = 512;
hop = transform_length/4;


% STFT +++++++++++++++++++++++++++++++++++++++++++++++
% Espera la entrada como una fila, si no, la transpone
if size(input,1) > 1
  input = input';
end

s = length(input);
w1 = transform_length;

% Enventanado para la STFT
if rem(w1, 2) == 0   % La ventana debe de ser impar
  w1 = w1 + 1;
end
halflen = (w1-1)/2;
halff = transform_length/2;   % punto medio de la ventana
halfwin = 0.5 * ( 1 + cos( pi * (0:halflen)/halflen));
win_stft = zeros(1, transform_length);
acthalflen = min(halff, halflen);
win_stft((halff+1):(halff+acthalflen)) = halfwin(1:acthalflen);
win_stft((halff+1):-1:(halff-acthalflen+2)) = halfwin(1:acthalflen);

% Inicializa el array de salida y las variables necesarias
out = zeros((1+transform_length/2),1+fix((s-transform_length)/hop));
c_stft = 1;
% Realiza la FFT utilizando una columna por cada ventana
for i = 0:hop:(s-transform_length)
  frame = win_stft.*input((i+1):(i+transform_length));
  tot = fft(frame);
  out(:,c_stft) = tot(1:(1+transform_length/2))';
  c_stft = c_stft+1;
end;

stft_signal = out;

% PVSAMPLE +++++++++++++++++++++++++++++++++++++++++++++++++

[rows, cols] = size(stft_signal);
t = 0:r:(cols-2);
% Tiene cuidado con las columnas porque se inicializa en 0 y hace falta la
% ventana siguiente para eo solapamiento

num = 2*(rows-1);

% Inicializa el array de salida
pv_signal = zeros(rows, length(t));

% Calcula la fase a esperar
dphi = zeros(1,num/2+1);
dphi(2:(1 + num/2)) = (2*pi*hop)./(num./(1:(num/2)));

% Phase accumulator
% Preset to phase of first frame for perfect reconstruction
% in case of 1:1 time scaling
ph = angle(stft_signal(:,1));

% Append a 'safety' column on to the end of b to avoid problems 
% taking *exactly* the last frame (i.e. 1*b(:,cols)+0*b(:,cols+1))
stft_signal = [stft_signal,zeros(rows,1)];

ocol = 1;
for i = t
  % Grab the two columns of b
  bcols = stft_signal(:,floor(i)+[1 2]);
  tf = i - floor(i);
  bmag = (1-tf)*abs(bcols(:,1)) + tf*(abs(bcols(:,2)));
  % calculate phase advance
  dp = angle(bcols(:,2)) - angle(bcols(:,1)) - dphi';
  % Reduce to -pi:pi range
  dp = dp - 2 * pi * round(dp/(2*pi));
  % Save the column
  pv_signal(:,ocol) = bmag .* exp(j*ph);
  % Cumulate phase, ready for next frame
  ph = ph + dphi' + dp;
  ocol = ocol+1;
end

% iSTFT +++++++++++++++++++++++++++++++++++++++++++++++++++++++++

s = size(pv_signal);
cols = s(2);
w_aux = transform_length;

if rem(w_aux, 2) == 0   % force window to be odd-len
  w_aux = w_aux + 1;
end
halflen = (w_aux-1)/2;
halff = transform_length/2;
halfwin = 0.5 * ( 1 + cos( pi * (0:halflen)/halflen));
win_istft = zeros(1, transform_length);
acthalflen = min(halff, halflen);
win_istft((halff+1):(halff+acthalflen)) = halfwin(1:acthalflen);
win_istft((halff+1):-1:(halff-acthalflen+2)) = halfwin(1:acthalflen);
% 2009-01-06: Make stft-istft loop be identity for 25% hop
win_istft = 2/3*win_istft;


w_aux = length(win_istft);
% now can set default hop
if hop == 0 
  hop = floor(w_aux/2);
end

xlen = transform_length + (cols-1)*hop;
istft_signal = zeros(1,xlen);

for i = 0:hop:(hop*(cols-1))
  ft = pv_signal(:,1+i/hop)';
  ft = [ft, conj(ft([((transform_length/2)):-1:2]))];
  px = real(ifft(ft));
  istft_signal((i+1):(i+transform_length)) = istft_signal((i+1):(i+transform_length))+px.*win_istft;
end

% PREPARACION FINAL +++++++++++++++++++++++++++++++++++++++++++++

pre_out = resample(istft_signal,2,1);

if length(pre_out) == length(input)
    out = pre_out';
else
    out = zeros(size(input));
    out(1,1:end) = pre_out(1,1:length(input))';
end

end

