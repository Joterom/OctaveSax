--------------------------------------------------------------
--------------------------------------------------------------
--                                                          --
-- This VHDL file has been generated by the verilog2vhdl    --
-- tool.                                                    --
-- Contact help@edautils.com  for support/info.--
--                                                          --
--                                                          --
--------------------------------------------------------------
--------------------------------------------------------------
--
--
-- Assumptions: 
--         (1) All the parameters are of type INTEGER, and hence the translated generics are of this type
--
--
-- Generated by : apache on 12/6/18 11:15 AM
--
--
library ieee;
use ieee.std_logic_1164.all;
package vl2vh_common_pack is 
    type vl2vh_memory_type is      array  ( natural range <> , natural range <>  )  of std_logic ;
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic;  constant falseval : std_logic)  return std_logic; 
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic_vector;  constant falseval : std_logic_vector)  return std_logic_vector; 
end package; 




package body vl2vh_common_pack is 
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic;  constant falseval : std_logic)  return std_logic is 
    begin
        if ( cond ) then 
             return trueval;
        else 
             return falseval;
        end if;
    end;
    function vl2vh_ternary_func(  constant cond : Boolean;  constant trueval : std_logic_vector;  constant falseval : std_logic_vector)  return std_logic_vector is 
    begin
        if ( cond ) then 
             return trueval;
        else 
             return falseval;
        end if;
    end;
end; 


library ieee;
library work;
use ieee.std_logic_1164.all;
use ieee.std_logic_misc.all;
use ieee.numeric_std.all;
use work.vl2vh_common_pack.all;
entity axis_i2s2 is 
generic (
        EOF_COUNT : INTEGER := 455 
    );
     port (
        axis_clk :  in std_logic;
        axis_resetn :  in std_logic;
        tx_axis_s_data :  in std_logic_vector( 31  downto 0  );
        tx_axis_s_valid :  in std_logic;
        tx_axis_s_ready :  out std_logic := '0';
        tx_axis_s_last :  in std_logic;
        rx_axis_m_data :  out std_logic_vector( 31  downto 0  );
        rx_axis_m_valid :  out std_logic := '0';
        rx_axis_m_ready :  in std_logic;
        rx_axis_m_last :  out std_logic := '0';
        tx_mclk :  out std_logic;
        tx_lrck :  out std_logic;
        tx_sclk :  out std_logic;
        tx_sdout :  out std_logic;
        rx_mclk :  out std_logic;
        rx_lrck :  out std_logic;
        rx_sclk :  out std_logic;
        rx_sdin :  in std_logic
    );
end entity; 


architecture rtl of axis_i2s2 is 
    signal count : std_logic_vector( 8  downto 0  ) := D"0" ;
    signal lrck : std_logic := count(8 );
    signal sclk : std_logic := count(2 );
    signal mclk : std_logic := axis_clk;
    signal tx_data_l : std_logic_vector( 31  downto 0  ) := 0 ;
    signal tx_data_r : std_logic_vector( 31  downto 0  ) := 0 ;
    signal tx_data_l_shift : std_logic_vector( 23  downto 0  ) := '0';
    signal tx_data_r_shift : std_logic_vector( 23  downto 0  ) := '0';
    signal din_sync_shift : std_logic_vector( 2  downto 0  ) := D"0" ;
    signal din_sync : std_logic := din_sync_shift(2 );
    signal rx_data_l_shift : std_logic_vector( 23  downto 0  ) := '0';
    signal rx_data_r_shift : std_logic_vector( 23  downto 0  ) := '0';
    signal rx_data_l : std_logic_vector( 31  downto 0  ) := '0';
    signal rx_data_r : std_logic_vector( 31  downto 0  ) := '0';
    begin 
        process 
        begin
            wait until ( axis_clk'EVENT and ( axis_clk = '1' )  ) ;
            count <= ( count + 1  ) ;
        end process;
        tx_lrck <= lrck;
        tx_sclk <= sclk;
        tx_mclk <= mclk;
        rx_lrck <= lrck;
        rx_sclk <= sclk;
        rx_mclk <= mclk;
        process 
        begin
            wait until ( axis_clk'EVENT and ( axis_clk = '1' )  ) ;
            if ( ( axis_resetn = '0' )  ) then 
                tx_axis_s_ready <= '0';
            else 
                if ( ( ( ( tx_axis_s_ready = '1' )  and ( tx_axis_s_valid = '1' )  )  and ( tx_axis_s_last = '1' )  )  ) then 
                    tx_axis_s_ready <= '0';
                else 
                    if ( ( count = '0' )  ) then 
                        tx_axis_s_ready <= '0';
                    else 
                        if ( ( count = EOF_COUNT )  ) then 
                            tx_axis_s_ready <= '1';
                        end if;
                    end if;
                end if;
            end if;
        end process;
        process 
        begin
            wait until ( axis_clk'EVENT and ( axis_clk = '1' )  ) ;
            if ( ( axis_resetn = '0' )  ) then 
                tx_data_r <= '0';
                tx_data_l <= '0';
            else 
                if ( ( ( tx_axis_s_valid = '1' )  and ( tx_axis_s_ready = '1' )  )  ) then 
                    if ( ( tx_axis_s_last = '1' )  ) then 
                        tx_data_r <= tx_axis_s_data;
                    else 
                        tx_data_l <= tx_axis_s_data;
                    end if;
                end if;
            end if;
        end process;
        process 
        begin
            wait until ( axis_clk'EVENT and ( axis_clk = '1' )  ) ;
            if ( ( count = B"000000111"  )  ) then 
                tx_data_l_shift <= tx_data_l(23  downto 0 );
                tx_data_r_shift <= tx_data_r(23  downto 0 );
            else 
                if ( ( ( ( count(2  downto 0 ) = B"111"  )  and ( count(7  downto 3 ) >= D"1"  )  )  and ( count(7  downto 3 ) <= D"24"  )  )  ) then 
                    if ( ( count(8 ) = '1' )  ) then 
                        tx_data_r_shift <= ( tx_data_r_shift(22  downto 0 ) & '0' );
                    else 
                        tx_data_l_shift <= ( tx_data_l_shift(22  downto 0 ) & '0' );
                    end if;
                end if;
            end if;
        end process;
        process 
        begin
            wait  on count, tx_data_l_shift, tx_data_r_shift;
            if ( ( ( count(7  downto 3 ) <= D"24"  )  and ( count(7  downto 3 ) >= D"1"  )  )  ) then 
                if ( ( count(8 ) = '1' )  ) then 
                    tx_sdout <= tx_data_r_shift(23 );
                else 
                    tx_sdout <= tx_data_l_shift(23 );
                end if;
            else 
                tx_sdout <= '0';
            end if;
        end process;
        process 
        begin
            wait until ( axis_clk'EVENT and ( axis_clk = '1' )  ) ;
            din_sync_shift <= ( din_sync_shift(1  downto 0 ) & rx_sdin );
        end process;
        process 
        begin
            wait until ( axis_clk'EVENT and ( axis_clk = '1' )  ) ;
            if ( ( ( ( count(2  downto 0 ) = B"011"  )  and ( count(7  downto 3 ) <= D"24"  )  )  and ( count(7  downto 3 ) >= D"1"  )  )  ) then 
                if ( ( lrck = '1' )  ) then 
                    rx_data_r_shift <= ( rx_data_r_shift & din_sync );
                else 
                    rx_data_l_shift <= ( rx_data_l_shift & din_sync );
                end if;
            end if;
        end process;
        process 
        begin
            wait until ( axis_clk'EVENT and ( axis_clk = '1' )  ) ;
            if ( ( axis_resetn = '0' )  ) then 
                rx_data_l <= '0';
                rx_data_r <= '0';
            else 
                if ( ( ( count = EOF_COUNT )  and ( rx_axis_m_valid = '0' )  )  ) then 
                    rx_data_l <= ( '0' & rx_data_l_shift );
                    rx_data_r <= ( '0' & rx_data_r_shift );
                end if;
            end if;
        end process;
        rx_axis_m_data <= vl2vh_ternary_func( ( rx_axis_m_last = '1' ) , rx_data_r, rx_data_l );
        process 
        begin
            wait until ( axis_clk'EVENT and ( axis_clk = '1' )  ) ;
            if ( ( axis_resetn = '0' )  ) then 
                rx_axis_m_valid <= '0';
            else 
                if ( ( ( count = EOF_COUNT )  and ( rx_axis_m_valid = '0' )  )  ) then 
                    rx_axis_m_valid <= '1';
                else 
                    if ( ( ( ( rx_axis_m_valid = '1' )  and ( rx_axis_m_ready = '1' )  )  and ( rx_axis_m_last = '1' )  )  ) then 
                        rx_axis_m_valid <= '0';
                    end if;
                end if;
            end if;
        end process;
        process 
        begin
            wait until ( axis_clk'EVENT and ( axis_clk = '1' )  ) ;
            if ( ( axis_resetn = '0' )  ) then 
                rx_axis_m_last <= '0';
            else 
                if ( ( ( count = EOF_COUNT )  and ( rx_axis_m_valid = '0' )  )  ) then 
                    rx_axis_m_last <= '0';
                else 
                    if ( ( ( rx_axis_m_valid = '1' )  and ( rx_axis_m_ready = '1' )  )  ) then 
                        rx_axis_m_last <= (  not rx_axis_m_last ) ;
                    end if;
                end if;
            end if;
        end process;
    end; 


